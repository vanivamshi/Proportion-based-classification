# -*- coding: utf-8 -*-
"""iris.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F_bM3ytqzqOdniKzN4r8HL_BWhxiMWwN
"""

import numpy as np
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from scipy.spatial.distance import euclidean

# Load Iris dataset
iris = load_iris()
X = iris.data
y = iris.target

# Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Function to compute proportions (complex: involving all 4 features)
def compute_proportions(X):
    proportions = []
    for row in X:
        a, b, c, d = row  # 4 features
        total_sum = a + b + c + d
        # Compute complex proportions involving all 4 features
        proportions.append([a / (total_sum + 1e-5), b / (total_sum + 1e-5), c / (total_sum + 1e-5)])
    return np.array(proportions)

# Compute proportions for training data
train_proportions = compute_proportions(X_train)

# Define quadrants for the training data based on proportions
q1, q2, q3, q4 = np.percentile(train_proportions, [25, 50, 75, 100], axis=0)

# Function to classify based on quadrant ranges
def classify_by_quadrants(test_point, q1, q2, q3, q4):
    # Check if the test point proportions fall between 75% of Q1 and 25% of Q4
    if np.all(0.75 * q1 <= test_point) and np.all(test_point <= 0.25 * q4):
        return "Q2 Class"  # Placeholder, corresponds to the training quadrant flower class

    return None  # Not classified by quadrant

# Function to classify by Euclidean distance
def classify_by_euclidean_distance(test_point, train_proportions, y_train):
    min_distance = float('inf')
    closest_class = -1
    for i, train_point in enumerate(train_proportions):
        dist = euclidean(test_point, train_point)
        if dist < min_distance:
            min_distance = dist
            closest_class = y_train[i]
    return closest_class

# Function to classify test data
def classify_test_data(X_test, q1, q2, q3, q4, train_proportions, y_train):
    test_proportions = compute_proportions(X_test)
    predictions = []
    for test_point in test_proportions:
        # Try to classify by quadrant ranges first
        quadrant_class = classify_by_quadrants(test_point, q1, q2, q3, q4)
        if quadrant_class:
            predictions.append(quadrant_class)
        else:
            # If not classified by quadrant, classify by Euclidean distance
            euclidean_class = classify_by_euclidean_distance(test_point, train_proportions, y_train)
            predictions.append(euclidean_class)
    return predictions

# Classify the test data using the quadrant and Euclidean distance methods
y_pred = classify_test_data(X_test, q1, q2, q3, q4, train_proportions, y_train)

# Convert "Q2 Class" placeholder to actual flower class
# Replace with actual mapping from quadrants to flower classes if needed

# Evaluate the model performance
y_pred = np.array([0 if p == "Q2 Class" else p for p in y_pred])  # Assuming 0 corresponds to Q2 Class for now
accuracy = accuracy_score(y_test, y_pred)

print(f"Accuracy: {accuracy * 100:.2f}%")